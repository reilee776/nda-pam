
#include <security/pam_appl.h>
#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <syslog.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>
#include <pwd.h>
#include <shadow.h>
#include <crypt.h>
#include "common.h"
#include <errno.h>
#include <sys/select.h>
#include <arpa/inet.h>
#include <ctype.h>
//#include "nd_pam.pb-c.h"
#include <pthread.h>
#include <sys/time.h> 
#include <sys/file.h>
#include <uuid/uuid.h>
#define MAX_LINE_LENGTH 1024
#define MAX_KEY_LENGTH 128
#define MAX_VALUE_LENGTH 256
#define STR_HELPER(x)   #x
#define STR(x)          STR_HELPER(x)

#define VENDER_NM       "netand"
#define CONFIG_DIR      "conf"
#define RULE_DIR	"rule"
#define LOG_DIR         "log"
#define SESSION_DIR	"sess"
#define CONFIG_FILE     "config.dat"
#define SESSION_FILE	"session.dat"
#define SULOG_FILE	"sulog.dat"
#define RULE_FILE	"rule.dat"
#define SURULE_FILE	"su_rule.dat"

#define SHARED_DATA_KEY "my_shared_data"

#define TMP_PATH        "tmp"
#define PIPE_NM         "nd_spam_fifo"

#define PAM_PIPE_FILE   TMP_PATH "/" PIPE_NM

#define PAM_SETTING_FILE        "/" VENDER_NM "/" CONFIG_DIR "/" CONFIG_FILE

#define PAM_SESSION_FILE	"/" VENDER_NM "/" SESSION_DIR "/" SESSION_FILE

#define PAM_RULE_FILE		"/" VENDER_NM "/" RULE_DIR "/" RULE_FILE

#define PAM_SURULE_FILE           "/" VENDER_NM "/" RULE_DIR "/" SURULE_FILE

#define PAM_SULOG_FILE		"/" VENDER_NM "/" LOG_DIR "/" SULOG_FILE

#define PAM_LOOPIPADDR 		"127.0.0.1"

#define SESSION_ID_LENGTH 16

#define SERVICE_SSHD_NAME	"sshd"

#define PAM_CONF_KEY_SERVERIP "SERVER_IP"
#define PAM_CONF_KEY_SERVERPORT "SERVER_PORT"

#define FAIL_COUNT_FILE "/tmp/pam_fail_count"

#define MAX_FAILED_ATTEMPTS 3
#define COUNTER_FILE "/var/log/pam_fail_count"

#define MAX_LOG_SIZE	1024

#define STR_SU	"su"
#define STR_SUL "su-l"

#define HIWARE_ACTUAL_NAME_FORMAT "HIWARE_ACTUAL_NAME=%s"
#define HIWARE_SESSION_KEY_FORMAT "HIWARE_SESSION_KEY=%s"
#define HIWARE_SU_ACTUAL_NAME_FORMAT "HIWARE_SU_ACTUAL_NAME=%s"
#define HIWARE_LOGIN_TYPE_FORMAT  "HIWARE_LOGIN_TYPE=%s"
#define HIWARE_ACCOUNT_FORMAT "HIWARE_SYSTEM_ACCOUNT=%s"
#define HIWARE_REMOTE_ADDR "HIWARE_REMOTE_ADDR=%s"
#define DB_PATH "/src/beetle/pam/nd_nix_pam/nd_nix_pam.db"

#define ND_PREFIX_LOGIN		"NDLOGIN"
#define ND_PREFIX_LOGOUT	"NDLOGOUT"
#define ND_HIWARE_ACTUALNM_KEY  "HIWARE_ACTUAL_NAME"

#define ND_SESSION_KEY		"ND_SESSION_KEY"

/*
	// su log format
	// <now session account>|<switch account>|<su command>|<tty>|<tty master>|<tty session client ip>|//<tty session client port>
*/
#define ND_SULOG_FORMAT "%s|%s|%s|%s|%s|%s|"

#define ND_PAMLOG_FORMAT_V2 		"<$@>action_type@>%s@>session_status@>%s@>account@>%s@>ipaddr@>%s@>sessionKey@>%s@>message@>%s$>"
#define ND_SULOG_FORMAT_V2 		"<$@>account@>%s@>switch_account@>%s@>su_command@>%s@>client_ip@>%s@>time@>%ld$>"
#define ND_SESSIONLOG_FORMAT_V2		"<$@>prefix@>%s@>session_id@>%s@>account@>%s@>uid@>%d@>gid@>%d@>isconsole@>%d@>ipaddr@>%s@>time@>%ld$>"

#define ND_LOGIN_MFA_ACCEPTED_MSG_FORMAT "Accepted hiware Multi-Prompt Verification/pam for %s from %s %s"
#define ND_LOGIN_MFA_EXCLUDED_MSG_FORMAT "Excluded by policy hiware Multi-Prompt Verification/pam for %s from %s %s"

int g_nFailCnt = 0;
void nd_pam_log(int level, char* filename, int line, const char *fmt, ...);

static const char *current_user;

pthread_mutex_t session_id_mutex;

#define __FILENAME__ (strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__)
#define nd_log(level, fmt, ...) nd_pam_log(level, __FILENAME__, __LINE__, fmt, ##__VA_ARGS__)

//nd_pam_sulog
#define nd_sulog(level, fmt, ...) nd_pam_sulog(level, __FILENAME__, __LINE__, fmt, ##__VA_ARGS__)

char g_sAccount[256];
char g_szLoginUserOrgName[1024];
char g_szHiwareAccount[256];
#define ESC "\033"
#define MAX_ATTEMPTS 3

bool g_isLogin = false;

int authentication_failed = 0;

#define PAM_DATA_SESSIONID	"ND_PAM_SESSION_ID"
#define PAM_DATA_FAILCNT	"ND_PAM_FAILCOUNT"

/*
	//It is an optional parameter that is a function pointer used for cleaning up the data. 
	//It is called when the PAM session ends.
*/
static void cleanup_func (pam_handle_t *pamh, void *data, int error_status) 	{

	free(data);
}

/*
	//Banner image displayed upon successful authentication.
*/
void print_nd_banner (void)
{
	printf ("\n\n");
        printf ("\x1b[31m     NNNN              NNNN  DDDDDDDDDDDDDDDDD                       \033[0m\n");
        printf ("\x1b[32m     NNNN  NNNN        NNNN                  DDDDD   nn    nn  eeeeeee  tttttttt     a      nn    nn   ddddddd   \033[0m\n");
        printf ("\x1b[33m     NNNN   NNNN       NNNN                  DDDDD   nnn   nn  ee          tt       aaa     nnn   nn   dd    dd  \033[0m\n");
        printf ("\x1b[34m     NNNN    NNNN      NNNN                  DDDDD   nnnn  nn  ee          tt      aa aa    nnnn  nn   dd     dd \033[0m\n");
        printf ("     NNNN     NNNN     NNNN                  DDDDD   nn nn nn  eeeeeee     tt     aa   aa   nn nn nn   dd     dd \033[0m\n");
        printf ("     NNNN      NNNN    NNNN                  DDDDD   nn  nnnn  ee          tt    aaaaa  aa  nn  nnnn   dd     dd \n");
        printf ("     NNNN       NNNN   NNNN                  DDDDD   nn   nnn  ee          tt    aaaaaa aa  nn   nnn   dd    dd  \n");
        printf ("     NNNNNNNNN   NNNN  NNNN                  DDDDD   nn    nn  eeeeeee     tt    aa     aa  nn    nn   ddddddd   \n");
        printf ("     NNNNNNNNNNN    NNNNNNN  DDDDDDDDDDDDDDDDDD                      \n");
        printf ("     NNNN             NNNNN  DDDDDDDDDDDDDDD                 \n");

        printf ("\n\n");

}

/*
	//Banner image displayed upon successful authentication. TEMP
*/
void print_nd_banner_type2 (void)
{
        printf ("\n\n");
	printf ("::::::::::::::::::::::::::::::::::::::::::: #\tWelcome to the Secure Login System! \n");
        printf (":::::       ::::::::::             :::::::: \n");
        printf (":::::    :   :::::::::    :::::::   ::::::: #\tHello, and welcome to Netand's secure environment. \n");
        printf (":::::    ::    :::::::    :::::::::   ::::: #\tPlease be mindful of your security at all times as you access this system.  \n");
        printf (":::::    ::::   ::::::    ::::::::::   :::: #\tWe strive to maintain the highest levels of protection for your data and privacy. \n");
        printf (":::::    :::::   :::::    ::::::::::   :::: \n");
        printf (":::::    ::::::   ::::    ::::::::::   :::: \n");
        printf (":::::    :::::::   :::    ::::::::::   :::: \n");
        printf (":::::       .::::   ::    ::::::::::   :::: \n");
        printf (":::::         ::::        :::::::::   ::::: \n");
        printf (":::::           ::::      ::::::::   :::::: \n");
        printf (":::::    ::::::::::::               ::::::: \n");
	printf ("::::::::::::::::::::::::::::::::::::::::::: \n");
        printf ("\n\n");

}

/*
	//Welcome message displayed upon successful authentication.
*/
void print_nd_warnning_msg (void)
{
	printf("#\tWelcome to the Secure Login System!\n");
        printf("#\n");
        printf("#\tHello, and welcome to Netand's secure environment. \n");
        printf("#\tPlease be mindful of your security at all times as you access this system. \n");
        printf("#\tWe strive to maintain the highest levels of protection for your data and privacy.\n");
        printf("#\n");
        printf("#\tThis is a secure login system designed to protect your credentials and sensitive information. \n");
        printf("#\tUnauthorized access is strictly prohibited, and all activities are logged and monitored for your safety.\n");
        printf("#\tPlease ensure that you are accessing this system for authorized purposes only. \n");
        printf("#\tMisuse of this system could result in severe penalties, including suspension of access.\n");
        printf("#\n");
        printf("#\t\x1b[31m⚠️ Attention: Network security is our top priority. Any suspicious activity will be flagged and reported to the \033[0m\n#\t\x1b[31mappropriate authorities.\033[0m\n");
        printf ("#\n");
        printf("#\tRemember, safeguarding your login credentials is your responsibility. Always keep them private and secure.\n");

        printf("#\tThank you for choosing Netand. Stay vigilant and proceed with caution. Secure your connection and have a \n#\tproductive session!\n\n");

}

/*
	//Function to generate a unique value for use as a session key.
	//generate session id
*/
void generate_session_id(char *session_id, size_t length) {

	syslog(LOG_ERR, "generate_session_id call");
	const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
	for (size_t i = 0; i < length; i++) {
		int key = rand() % (int)(sizeof(charset) - 1);
		session_id[i] = charset[key];
	}
	session_id[length] = '\0'; // 문자열 종료 문자 추가
}

/*
	//Function to retrieve the failure count stored locally.
*/
int read_fail_count(const char *username) {
	FILE *file = fopen(COUNTER_FILE, "r");
	if (!file) {
		return 0; 
	}

	char line[256];
	while (fgets(line, sizeof(line), file)) {
		char user[256];
		int count;
		sscanf(line, "%s %d", user, &count);
		if (strcmp(user, username) == 0) {
			fclose(file);
		    	return count;
		}
	}
	fclose(file);
	return 0; 
}

/*
	//Function to retrieve the failure count stored locally.
*/
void increment_fail_count(const char *username) {
	FILE *file = fopen(COUNTER_FILE, "r+");
	if (!file) {
		return; 
	}

	char line[256];
	int found = 0;
	int count = 0;

	while (fgets(line, sizeof(line), file)) {
		char user[256];
		sscanf(line, "%s %d", user, &count);
		if (strcmp(user, username) == 0) {
			found = 1;
		    	count++; 
		    	break;
		}
	}

	rewind(file);

	if (found) {
		fprintf(file, "%s %d\n", username, count);
	} else {
		fprintf(file, "%s %d\n", username, 1); 
	}

	fclose(file);
}

/*
	//"Function to reset the authentication failure count.
*/
void reset_fail_count(const char *username) {
	FILE *file = fopen(COUNTER_FILE, "r");
	if (!file) {
		return; 
	}

	char temp_file[] = "/tmp/pam_fail_count.tmp";
	FILE *temp = fopen(temp_file, "w");
	char line[256];


	while (fgets(line, sizeof(line), file)) {
		char user[256];
		int count;
		sscanf(line, "%s %d", user, &count);
		if (strcmp(user, username) != 0) {
			fprintf(temp, "%s %d\n", user, count);
		}
	}

	fclose(file);
	fclose(temp);


	rename(temp_file, COUNTER_FILE);
}

/* 
 	//get timestamp
*/
void get_timestamp(char *buffer, size_t size) {
	struct timespec ts;
	struct tm tm_info;

	clock_gettime(CLOCK_REALTIME, &ts);

	localtime_r(&ts.tv_sec, &tm_info);

	// yyyy-mm-dd hh:mm:ss.ffffff 
	snprintf(buffer, size, "[%04d-%02d-%02d %02d:%02d:%02d.%06ld]",
	     tm_info.tm_year + 1900, 
	     tm_info.tm_mon + 1,    
	     tm_info.tm_mday,
	     tm_info.tm_hour,
	     tm_info.tm_min,
	     tm_info.tm_sec,
	     ts.tv_nsec / 1000); 
}

/*
 	//pam log
	//Function to log messages in the PAM module.
*/
void nd_pam_log(int level, char* filename, int line, const char *fmt, ...)	{

	char timestamp[50];
	size_t len;
	va_list args;
	const char *log_file = "/netand/log/nd_pam_log.log";
	char sLogMsg[1024] = {0,}, sBakStr[1024] = {0,};

	get_timestamp(timestamp, sizeof (timestamp));
	va_start(args, fmt);
	vsnprintf (sBakStr, sizeof (sBakStr), fmt, args);
	va_end(args);

	len = strlen(sBakStr);

	snprintf (sLogMsg, sizeof (sLogMsg), "%s(%s) <%s:%d>    %s\n",timestamp, nd_log_level[level].stLevel, filename, line, sBakStr);

	if (sLogMsg[strlen(sLogMsg) -1] == '\n')
		sLogMsg[strlen(sLogMsg) -1] = '\0';

	FILE *file = fopen(log_file, "a");
	if (file) {

		fprintf(file, "%s\n", sLogMsg);
		fclose(file);
	} 
}

void nd_pam_sulog(int level, char* filename, int line, const char *fmt, ...) ;

void nd_pam_log_v2(char* action_type, char* session_status, char * current_user, char * ipAddress, char * sessionKey, char *fmt, ... )
{
	size_t len;
        va_list args;
	char sLogMsg[1024] = {0,}, sBakStr[1024] = {0,};
        const char *log_file = "/netand/log/nd_pam_log.log";

	va_start(args, fmt);
        vsnprintf (sBakStr, sizeof (sBakStr), fmt, args);
	va_end(args);

	snprintf (sLogMsg, sizeof (sLogMsg), ND_PAMLOG_FORMAT_V2,action_type, session_status, current_user, ipAddress, sessionKey, sBakStr);

        if (sLogMsg[strlen(sLogMsg) -1] == '\n')
                sLogMsg[strlen(sLogMsg) -1] = '\0';

        FILE *file = fopen(log_file, "a");
        if (file) {

                fprintf(file, "%s\n", sLogMsg);
                fclose(file);
        }
}

#ifdef _LOG_TYPE_V2
void nd_pam_log_v2(struct pam_log_item * plog)
{
	const char *log_file = "/netand/log/nd_pam_log.log";

	if (plog == NULL )
		return;

	char sLogMsg[1024] = {0,};

	snprintf (sLogMsg, sizeof (sLogMsg), ND_PAMLOG_FORMAT_V2,plog->action_type, plog->session_status, plog->account, plog->ipaddr, plog->sessionKey, plog->message);

	if (sLogMsg[strlen(sLogMsg) -1] == '\n')
                sLogMsg[strlen(sLogMsg) -1] = '\0';

	FILE *file = fopen(log_file, "a");
        if (file) {

                fprintf(file, "%s\n", sLogMsg);
                fclose(file);
        }
}
#endif

/*
        //pam log
        //Function to log messages in the PAM module.
*/
void nd_pam_sulog(int level, char* filename, int line, const char *fmt, ...)      {

        char timestamp[50];
        size_t len;
        va_list args;
        const char *log_file = PAM_SULOG_FILE;
        char sLogMsg[1024] = {0,}, sBakStr[1024] = {0,};

        get_timestamp(timestamp, sizeof (timestamp));
        va_start(args, fmt);
        vsnprintf (sBakStr, sizeof (sBakStr), fmt, args);
        va_end(args);

        len = strlen(sBakStr);

        snprintf (sLogMsg, sizeof (sLogMsg), "%s(%s) <%s:%d>    %s\n",timestamp, nd_log_level[level].stLevel, filename, line, sBakStr);

        if (sLogMsg[strlen(sLogMsg) -1] == '\n')
                sLogMsg[strlen(sLogMsg) -1] = '\0';

        FILE *file = fopen(log_file, "a");
        if (file) {

                fprintf(file, "%s\n", sLogMsg);
                fclose(file);
        }
}

//ND_SULOG_FORMAT_V2
void nd_pam_sulog_v2(char * account, char * switch_account, char * su_command, char * client_ip)
{
	const char *log_file = PAM_SULOG_FILE;
        char sLogMsg[1024] = {0,};

	snprintf (sLogMsg, sizeof (sLogMsg), ND_SULOG_FORMAT_V2,account, switch_account, su_command, client_ip, (long)time(NULL) );

	if (sLogMsg[strlen(sLogMsg) -1] == '\n')
                sLogMsg[strlen(sLogMsg) -1] = '\0';

	FILE *file = fopen(log_file, "a");
        if (file) {

                fprintf(file, "%s\n", sLogMsg);
                fclose(file);
        }


}
/*
	// type : 0 = open(connect), 1 = close (disconnect)
	// Function to log user login/logout session activities.
*/
void nd_pam_session_log(int type, const char *fmt, ...)      {

        char timestamp[50];
        size_t len;
        va_list args;
        const char *log_file = "/netand/log/nd_pam_session.log";
        char sLogMsg[1024] = {0,}, sBakStr[1024] = {0,};

        //get_timestamp(timestamp, sizeof (timestamp));
        va_start(args, fmt);
        vsnprintf (sBakStr, sizeof (sBakStr), fmt, args);
        va_end(args);

        len = strlen(sBakStr);

        if (len == 0 || sBakStr[len-1] != '\n') {
                snprintf (sLogMsg, sizeof (sLogMsg), "%s|%s\n", nd_slog_type[type].stType,  sBakStr);
        }else
        {
		snprintf (sLogMsg, sizeof (sLogMsg), "%s|%s", nd_slog_type[type].stType,  sBakStr);
        }

        FILE *file = fopen(log_file, "a");
        if (file) {

                fprintf(file, "%s", sLogMsg);
                fclose(file);
        }
}

void nd_pam_session_log_v2(char *prefix, char* session_id, char* account, int uid, int gid, bool isConsole, char* ipAddr, long time)      {

        char timestamp[50];
        size_t len;
        va_list args;
        const char *log_file = "/netand/log/nd_pam_session.log";
        char sLogMsg[1024] = {0,};

	snprintf (sLogMsg, sizeof (sLogMsg), ND_SESSIONLOG_FORMAT_V2, prefix, session_id, account, uid, gid, isConsole, ipAddr, time);
	if (sLogMsg[strlen(sLogMsg) -1] == '\n')
                sLogMsg[strlen(sLogMsg) -1] = '\0';

        FILE *file = fopen(log_file, "a");
        if (file) {

                fprintf(file, "%s\n", sLogMsg);
                fclose(file);
        }
}



/*
	//space removal function
*/
void trim_whitespace(char *str) {
        char *end;
	
	/*
        	// Remove leading space
	*/
        while (isspace((unsigned char)*str)) str++;

        if (*str == 0) return;

	/*
        	// remove trailing space
	*/
        end = str + strlen(str) - 1;
        while (end > str && isspace((unsigned char)*end)) end--;

        *(end + 1) = 0;
}


/*
	//read inf fuction
*/
char *get_value_from_inf(const char *filename, const char *target_section, const char *target_key) {

        FILE *file = fopen(filename, "r");
        if (!file) {
                perror("Error opening file");
                return NULL;
        }

        char line[MAX_LINE_LENGTH];
        char current_section[MAX_KEY_LENGTH] = "";
        static char value[MAX_VALUE_LENGTH];

        while (fgets(line, sizeof(line), file)) {
                trim_whitespace(line);

		/*
                	// Ignore empty lines or comments
		*/
                if (line[0] == '\0' || line[0] == ';' || line[0] == '#') {
                        continue;
                }

		/*
                	//  section syntax([Section])
		*/
                if (line[0] == '[' && line[strlen(line) - 1] == ']') {
                        strncpy(current_section, line + 1, strlen(line) - 2);
                        current_section[strlen(line) - 2] = '\0';
                }
                // In case of key=value syntax
                else if (strcmp(current_section, target_section) == 0) {
                        char *equals_pos = strchr(line, '=');
                        if (equals_pos) {
                                *equals_pos = '\0';

                                char key[MAX_KEY_LENGTH];
                                strncpy(key, line, sizeof(key));
                                trim_whitespace(key);

                  		/*
			              // Return value if keys matce
				*/
				
				if (strcmp(key, target_key) == 0) 	{
				 	char *value = malloc(MAX_VALUE_LENGTH);
				    	if (value) {
						strncpy(value, equals_pos + 1, MAX_VALUE_LENGTH - 1);
						value[MAX_VALUE_LENGTH - 1] = '\0'; // null 종료
						trim_whitespace(value);
						fclose(file);
						return value; // 동적으로 할당된 메모리 반환
				    } else 	{
						fclose(file);
						return NULL; // 메모리 할당 실패
				    }
				}
#ifdef _OLD_SRC
                                if (strcmp(key, target_key) == 0) {
                                    strncpy(value, equals_pos + 1, sizeof(value));
                                    trim_whitespace(value);
                                    fclose(file);
                                    return value;  // return value
                                }

#endif 
                        }
                }
        }

        fclose(file);
        return NULL;  //If no value is found
}

/*
	// read config
*/
int read_server_config(const char *section, char *ip_buffer, size_t ip_buffer_size, int *port)       {

        char *server_ip = get_value_from_inf(PAM_SETTING_FILE, section, PAM_CONF_KEY_SERVERIP);
        char *server_port = get_value_from_inf(PAM_SETTING_FILE, section, PAM_CONF_KEY_SERVERPORT);


        if (server_ip != NULL ) {
                strncpy (ip_buffer, server_ip, ip_buffer_size -1);
                ip_buffer[ip_buffer_size -1] = '\0';
        }else   {
                printf("Failed to read server IP\n");
                return -1;
        }

        if (server_port != NULL)        {

                *port = atoi (server_port);
        }else   {
                printf("failed to read server PORT\n");
                return -1;
        }

        return 0;
}

/*
	//
	//socket connection function
*/
int connect_to_server(int *sock, const char *section) {

        char szMsg[1024] = {0,};
        char server_ip[16];
        int server_port;

	/*
        	// Read server settings
	*/
        if (read_server_config(section, server_ip, sizeof(server_ip), &server_port) != 0) {
                return -1;
        }

        struct sockaddr_in server;

	/*
        	// create socket
	*/
        *sock = socket(AF_INET, SOCK_STREAM, 0);
        if (*sock == -1) {
                sprintf(szMsg,"Failed socket creation - %s", strerror(errno));
                return -2;
        }

	syslog (LOG_ERR, "connect_to_server : ip : |%s|, port:|%d|", server_ip, server_port);

	/*
        	// Setting server address
	*/
        server.sin_family = AF_INET;
        server.sin_port = htons(server_port);
        server.sin_addr.s_addr = inet_addr(server_ip);

	/*
        	// connect server
	*/
        if (connect(*sock, (struct sockaddr *)&server, sizeof(server)) < 0) {
		syslog (LOG_ERR,"connect error (%s)", strerror(errno));
                perror("connect failed.");
                close(*sock);
                return -3;
        }

        return 0; // success
}

/*
	//Function to verify compliance with policies using the information of the access subject stored in the local policy file.
*/
bool find_match_rule (struct pam_rule_info *rule)
{

	FILE *file = fopen (PAM_RULE_FILE, "r");
	if (file == NULL )	{
		return false;
	}

	char line[MAX_LINE_LENGTH];
	while (fgets (line, sizeof (line), file) != NULL )	{

		line [strcspn(line, "\n")] = 0;

		char * token = strtok(line, "|");
		struct pam_rule_info temp_rule;
		memset (&temp_rule, 0, sizeof (temp_rule));

		int index = 0;
		while (token != NULL && index < 5)	{
			switch (index )	{

				case 0: //USER NAME
					strncpy (temp_rule.username, token, sizeof (temp_rule.username) -1);
					break;

				case 1: //ip address
					strncpy (temp_rule.ipaddr, token, sizeof (temp_rule.ipaddr) -1 );
					break;

				default:
					break;
				
			}

			index ++;
			token = strtok(NULL, "|");
		}

		if (
			strcmp (temp_rule.username, rule->username) == 0 &&
			strcmp (temp_rule.ipaddr, rule->ipaddr) == 0	
			
			/*&& 
			temp_rule.isMFA == rule->isMFA &&
			strcmp (temp_rule.hiwareAccount, rule->hiwareAccount) == 0 &&
			strcmp (temp_rule.hiwareActualName, rule->hiwareActualName) == 0 
			*/
		) 
		{
			fclose (file);
			return true;
		}
	}

	fclose (file);

	return false;
}

int read_pam_config(const char *filename, pam_config *config) {

	FILE *file = fopen(filename, "r");
	if (file == NULL) {
		perror("Failed to open file");
		return -1; // 파일 열기 실패
	}

	char line[MAX_LINE_LENGTH];
	while (fgets(line, sizeof(line), file) != NULL) {
		// 줄 끝의 개행 문자 제거
		line[strcspn(line, "\n")] = 0;

		// 키-값 분리
		char *key = strtok(line, "=");
		char *value = strtok(NULL, "=");

		// PAM_MODE 설정
		if (key && value) {
		    if (strcmp(key, "PAM_MODE") == 0) {
			strncpy(config->pam_mode, value, sizeof(config->pam_mode) - 1);
			config->pam_mode[sizeof(config->pam_mode) - 1] = '\0'; // null-terminate
		    } else if (strcmp(key, "PAM_SU_CONTROL") == 0) {
			strncpy(config->pam_su_control, value, sizeof(config->pam_su_control) - 1);
			config->pam_su_control[sizeof(config->pam_su_control) - 1] = '\0'; // null-terminate
		    }
		}
	}

	fclose(file);
	return 0; // 성공적으로 읽음
}

/*
        //Function to verify compliance with policies using the information of the access subject stored in the local policy file.
*/
bool find_match_rule_for_connnectinfo (const char *username, const char * remoteipaddr/*, bool * isMFA*/)
{

        FILE *file = fopen (PAM_RULE_FILE, "r");
        if (file == NULL )      {
                return false;
        }

        char line[MAX_LINE_LENGTH];
        while (fgets (line, sizeof (line), file) != NULL )      {

                line [strcspn(line, "\n")] = 0;

                char * token = strtok(line, "|");
                struct pam_rule_info temp_rule;
                memset (&temp_rule, 0, sizeof (temp_rule));

                int index = 0;
                while (token != NULL && index < 5)      {
                        switch (index ) {

				case 0: //USER NAME
                                        strncpy (temp_rule.username, token, sizeof (temp_rule.username) -1);
                                        break;

                                case 1: //ip address
                                        strncpy (temp_rule.ipaddr, token, sizeof (temp_rule.ipaddr) -1 );
                                        break;

                                default:
                                        break;

                        }

                        index ++;
                        token = strtok(NULL, "|");
                }

                if (
                        strcmp (temp_rule.username, username) == 0 &&
                        strcmp (temp_rule.ipaddr, remoteipaddr) == 0 
                )
                {
                        fclose (file);
                        return true;
                }
        }

        fclose (file);

        return false;
}

bool is_user_allowed(const char *username, const char *allowed_users) {

	char allowed_users_copy[1024];
	strncpy(allowed_users_copy, allowed_users, sizeof(allowed_users_copy) - 1);
	allowed_users_copy[sizeof(allowed_users_copy) - 1] = '\0'; // Null termination

	char *user_token = strtok(allowed_users_copy, ", ");
	while (user_token != NULL) 	{

		if (strcmp(user_token, username) == 0) 	{
	    		return true;  
		}

		user_token = strtok(NULL, ", ");
	}

	return false;  
}

bool find_match_su_rule_for_connnectinfo (const char *username, const char * remoteipaddr, const char * su_user)
{

        FILE *file = fopen (PAM_SURULE_FILE, "r");
        if (file == NULL )      {
                return false;
        }


	bool bFindAllowUser = false;
        char line[MAX_LINE_LENGTH];
        while (fgets (line, sizeof (line), file) != NULL )      {

                line [strcspn(line, "\n")] = 0;

                char * token = strtok(line, "|");
                struct pam_rule_info temp_rule;
                memset (&temp_rule, 0, sizeof (temp_rule));

                int index = 0;
                while (token != NULL && index < 5)      {
                        switch (index ) {

                                case 0: //USER NAME
                                        strncpy (temp_rule.username, token, sizeof (temp_rule.username) -1);
                                        break;

                                case 1: //ip address
                                        strncpy (temp_rule.ipaddr, token, sizeof (temp_rule.ipaddr) -1 );
                                        break;

				case 2: //allowed su target rule
					if (is_user_allowed (su_user, token) == true )
					{
						bFindAllowUser = true;
					}	break;
                                default:
                                        break;

                        }

                        index ++;
                        token = strtok(NULL, "|");
                }


                if (
                        strcmp (temp_rule.username, username) == 0 &&
                        strcmp (temp_rule.ipaddr, remoteipaddr) == 0 &&
			bFindAllowUser == true
                )
                {
                        fclose (file);
                        return true;
                }
        }

        fclose (file);

        return false;
}


/*
	// data transfer function
*/
int send_data(int sock, const char *data) 	{

    	if (send(sock, data, strlen(data), 0) < 0) 	{
        	fprintf(stderr, "Data transfer failure: %s\n", strerror(errno));
        	return -1;
    	}
    	return 0; // success
}

/*
	//
*/
int check_server_connection(const char *ip, int port) 	{

	int sock;
	struct sockaddr_in server;


	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) 		{
		return 0; 
	}

	server.sin_family = AF_INET;
	server.sin_port = htons(port);
	server.sin_addr.s_addr = inet_addr(ip);


	if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0) 	{
		close(sock);
		return 0; 
	}

	close(sock);
	return 1; 
}

/*
	//data reception function
*/
int receive_data(int sock, char *buffer, size_t buffer_size) 	{

    	ssize_t bytes_received = recv(sock, buffer, buffer_size - 1, 0);
    	if (bytes_received < 0) {
        	fprintf(stderr, "Receive failure data : %s\n", strerror(errno));
        	return -1;
    	}
    	buffer[bytes_received] = '\0';
    	return 0; // success
}

/*
	// get encrypted password
*/
const char* get_encrypted_password_from_shadow_v2(const char* username) 	{
	
	struct spwd *sp = getspnam(username);
	if (sp == NULL) 	{
		return NULL; 
	}
	return sp->sp_pwdp; 
}

/*
	// get encrypted password
	// This is a function that retrieves a specific user's password hash from the /etc/shadow file.
*/
const char* get_encrypted_password_from_shadow(const char* user) 	{

	static char encrypted_passwd[MAX_LINE_LENGTH];
	struct spwd *sp;
	struct passwd *pw;
	char *shadow_path = "/etc/shadow";
	FILE *shadow_file;
	char line[MAX_LINE_LENGTH];
	char *username;
	char *password_hash;

	/*
		// /etc/shadow open file
	*/
	shadow_file = fopen(shadow_path, "r");
	if (!shadow_file) {
		syslog(LOG_ERR, "Error opening file: %s", strerror(errno));
		return NULL;
	}

	while (fgets(line, sizeof(line), shadow_file)) {

		username = strtok(line, ":");
		password_hash = strtok(NULL, ":");

		if (username && password_hash && strcmp(username, user) == 0) {
		    strncpy(encrypted_passwd, password_hash, sizeof(encrypted_passwd) - 1);
		    encrypted_passwd[sizeof(encrypted_passwd) - 1] = '\0'; // null-terminate
		    fclose(shadow_file);
		    return encrypted_passwd;
		}
	}

	fclose(shadow_file);
	return NULL;
}


/*
	//get user information
*/
void get_user_info(struct pam_user_info *user_info, pam_handle_t *pamh) {

	char *crypted;
	const char *input_passwd;
	const char *encrypted_passwd;
        int retval = 0;

	if (user_info == NULL || pamh == NULL) {

		pam_syslog (pamh, LOG_ERR, "get_user_info invailed parameter.");

		nd_log (NDLOG_ERR, "The input parameter information of the function is not valid.");
		return;
	}

	/*
		// Getting the Current Username Using PAM
	*/
	const char *username;
	if (pam_get_user(pamh, &username, NULL) == PAM_SUCCESS && username != NULL)	 {

		strncpy(user_info->username, username, sizeof(user_info->username) - 1);
		user_info->username[sizeof(user_info->username) - 1] = '\0';
	}else
		pam_syslog (pamh, LOG_ERR, "pam_get_user failed...");

	/*
		// Getting the user input password.
	*/
	retval = pam_get_authtok(pamh, PAM_AUTHTOK, &input_passwd, NULL);
        if (retval != PAM_SUCCESS) {

                nd_log(NDLOG_ERR,"failed to get user password...");
		pam_syslog (pamh, LOG_ERR , "fail to get user password");
                return;
        }


	strncpy (user_info->realpwd, input_passwd, sizeof (user_info->realpwd));

	/*
		//Determining the login type of the current session (distinguishing between console login and terminal login).
	*/
	user_info->isConsole = false;
	pam_get_item(pamh, PAM_TTY, (const void **)&user_info->tty);
        if (user_info->tty)        {

                if (strncmp(user_info->tty, "tty", 3) == 0 )       {
                        user_info->isConsole = true;
                }
        }else 
	{
		pam_syslog (pamh, LOG_ERR, "failed to get tty ..");
	}

	/*
		//Receives a username and returns the corresponding user's password hash.
	*/
	user_info->encrypted_password = get_encrypted_password_from_shadow(username);
	if (!user_info->encrypted_password )	{
		pam_syslog (pamh, LOG_ERR, "failed to get encrypted password");
		return;
	}

	/*
		//Calls the crypt function using the user input password (input_passwd) along with the user's password hash (user_info->encrypted_password).
	*/
	crypted = crypt(input_passwd, user_info->encrypted_password);
        if (strcmp(crypted, user_info->encrypted_password) == 0) {
                user_info->login_status = 0;
        } else {
                user_info->login_status = 1;
        }


	/*
		// Getting the UID and GID
	*/
	struct passwd *pw = getpwnam(user_info->username);
	if (pw != NULL) {

		user_info->uid = pw->pw_uid;
		user_info->gid = pw->pw_gid;
		strncpy(user_info->home_directory, pw->pw_dir, sizeof(user_info->home_directory) - 1);
		user_info->home_directory[sizeof(user_info->home_directory) - 1] = '\0';
		strncpy(user_info->shell, pw->pw_shell, sizeof(user_info->shell) - 1);
		user_info->shell[sizeof(user_info->shell) - 1] = '\0';
	}
	else 
		pam_syslog (pamh, LOG_ERR, "failed to get pw and uid gid");

	/*
		// Authentication Method (ex: password)
	*/
	strncpy(user_info->auth_method, "password", sizeof(user_info->auth_method) - 1);
	user_info->auth_method[sizeof(user_info->auth_method) - 1] = '\0';

	/*
		// The IP address cannot be retrieved directly in the PAM environment.
	*/
	if (user_info->isConsole == false )        {
                retval = pam_get_item(pamh, PAM_RHOST, (const void **)&user_info->ip_address);
                if (retval == PAM_SUCCESS && user_info->ip_address) {
			pam_syslog(pamh, LOG_INFO,"get success remote ipaddress");
                } else {
			pam_syslog(pamh, LOG_INFO,"fail to get remote ip address");
                }
        }

	/*
		// Retrieving the current service name from PAM (Pluggable Authentication Module).
		//service
	*/

	retval = pam_get_item(pamh, PAM_SERVICE, (const void**)&user_info->service);
	if (retval == PAM_SUCCESS && user_info->service)
	{
		//log message
	}else
		pam_syslog (pamh, LOG_ERR, "failed to get service");
	

	/*
		// login time
	*/
	user_info->login_time = time(NULL);

	/*
		// session ID (ex: Generate UUID or Unique Session ID)
	*/
	strncpy(user_info->session_id, "session1234", sizeof(user_info->session_id) - 1);
	user_info->session_id[sizeof(user_info->session_id) - 1] = '\0';

	/*
		// login status (ex: Setting success)
	*/
	user_info->login_status = 0; // Initial Value

	/*
		// Authentication Failure count (initial value)
	*/
	user_info->auth_fail_count = 0; // initial value

	/*
		// Additional Authentication Information
	*/
	strncpy(user_info->mfa_info, "none", sizeof(user_info->mfa_info) - 1);
	user_info->mfa_info[sizeof(user_info->mfa_info) - 1] = '\0';
}

void serialize_auth_info(struct pam_auth_req_info *info, char *output, size_t output_size) {

	int username_len = strlen(info->username);
	int userpwd_len = strlen(info->userpwd);
	int hiwarename_len = strlen(info->hiwarename);
	int hiwarepwd_len = strlen(info->hiwarepwd);
	int remoteipaddr_len = strlen(info->remoteipaddr);

	snprintf(output, output_size,
	     "#012#%03d%s#022#%03d%s#032#%03d%s#042#%03d%s#052#%03d%s",
	     username_len, info->username,
	     userpwd_len, info->userpwd,
	     hiwarename_len, info->hiwarename,
	     hiwarepwd_len, info->hiwarepwd,
	     remoteipaddr_len, info->remoteipaddr);
}

int set_pam_data(pam_handle_t *pamh, const char *data_name, const char *data_value, 
                 void (*cleanup_func)(pam_handle_t *pamh, void *data, int error_status)) {

	if (pamh == NULL || data_name == NULL || data_value == NULL) {
		return PAM_BUF_ERR; 
	}

	char *data_copy = strdup(data_value);	// strdup performs a similar role to malloc by allocating memory and copying the string
	if (data_copy == NULL) {
		return PAM_BUF_ERR;
	}

	int retval = pam_set_data(pamh, data_name, data_copy, cleanup_func);
	if (retval != PAM_SUCCESS) {
		free(data_copy); 
	}

	return retval;
}

int get_pam_data(pam_handle_t *pamh, const char *data_name, const void **data_out) 	{

	if (pamh == NULL || data_name == NULL || data_out == NULL) {
		return PAM_BUF_ERR; 
	}

	int retval = pam_get_data(pamh, data_name, data_out);
	if (retval != PAM_SUCCESS) {
		*data_out = NULL; 
	}

	return retval;
}

int set_pam_data_number(pam_handle_t *pamh, const char *data_name, int number,
                        void (*cleanup_func)(pam_handle_t *pamh, void *data, int error_status)) 	{

	nd_log(NDLOG_ERR, "call set_pam_data_number..");

	if (pamh == NULL || data_name == NULL) {
		nd_log(NDLOG_ERR, "PAM_BUF_ERR");
		return PAM_BUF_ERR;
	}

	char *data_copy = malloc(12);
	if (data_copy == NULL) {
		nd_log(NDLOG_ERR, "PAM_BUF_ERR2");
		return PAM_BUF_ERR; 
	}

	snprintf (data_copy, 12, "%d", number);

	int retval = pam_set_data(pamh, data_name, data_copy, cleanup_func);
	if (retval != PAM_SUCCESS) {
		nd_log(NDLOG_ERR, "pam_set_data fail (%d)", retval);
		free(data_copy); 
	}

	return retval;
}

int get_pam_data_number(pam_handle_t *pamh, const char *data_name, int *number_out) 	{

	if (pamh == NULL || data_name == NULL || number_out == NULL) {
		nd_log(NDLOG_ERR, "PAM_BUF_ERR !!!!");
		return PAM_BUF_ERR; 
	}

	const char *data_copy; 
	int retval = pam_get_data(pamh, data_name, (const void **)&data_copy);

	if (retval != PAM_SUCCESS || data_copy == NULL) {
		nd_log(NDLOG_ERR, "pam_get_data fail...(%d)[%s]", retval, data_name);
		return retval; 
	}

	char *endptr; 
	long value = strtol(data_copy, &endptr, 10); 

	if (*endptr != '\0') { 
		nd_log(NDLOG_ERR, "strtol fail!!!");
		return PAM_BUF_ERR; 
	}

	*number_out = (int)value; 

	return PAM_SUCCESS; 
}

/*
	//su control get  who commond output data
*/
pam_client_info  get_su_master_info (pam_handle_t *pamh)
{
	const char      *tty;
	bool bFinded = false;
	bool found = false;
	int retval = 0;
	pam_client_info clientInfo;
	const char *ssh_connection = getenv("SSH_CONNECTION");

	strcpy(clientInfo.ip, NONE_STRING);
    	strcpy(clientInfo.port, NONE_STRING);
    	strcpy(clientInfo.tty, NONE_STRING);

	if (ssh_connection) {
		// SSH_CONNECTION format: "client_ip client_port server_ip server_port"
		char *token = strtok((char *)ssh_connection, " ");
		if (token != NULL) {
			strncpy(clientInfo.ip, token, INET_ADDRSTRLEN); 
			clientInfo.ip[INET_ADDRSTRLEN - 1] = '\0'; // null-terminate

			token = strtok(NULL, " ");
			if (token != NULL) {
				strncpy(clientInfo.port, token, sizeof(clientInfo.port)); 
				clientInfo.port[sizeof(clientInfo.port) - 1] = '\0'; 
			}
		}
		found = true;
	} else {

		retval = pam_get_item(pamh, PAM_TTY, (const void **)&tty);
		if (retval == PAM_SUCCESS) 
		{
			strncpy(clientInfo.tty, tty, sizeof(clientInfo.tty));
			clientInfo.tty[sizeof(clientInfo.tty) - 1] = '\0'; 

		    	FILE *fp = popen("who", "r");
		    	if (fp != NULL) 
			{
				char buffer[256];
				while (fgets(buffer, sizeof(buffer), fp) != NULL) 
				{
			    		char *user = strtok(buffer, " ");
			    		char *tty1 = strtok(NULL, " ");
			    		char *time = strtok(NULL, " ");
			    		time = strtok(NULL, " ");
			    		char *ip = strtok(NULL, " ");

			    		if (ip != NULL && ip[0] == '(') 
					{
						ip++;
						char *end = strchr(ip, ')');
						if (end != NULL) 	{
				    			*end = '\0';
						}
			    		}	


			    		if (strcmp(tty1, clientInfo.tty) == 0) {
						strncpy(clientInfo.ip, ip, INET_ADDRSTRLEN);
						clientInfo.ip[INET_ADDRSTRLEN - 1] = '\0'; 
						found = true;
						break;
			    		}
				}
			pclose(fp);
		    	}
		}
	}

	if (!found) {
		strcpy(clientInfo.ip, NONE_STRING);
		strcpy(clientInfo.port, NONE_STRING);
	}

	return clientInfo;
}


/*
	//
*/
struct st_hiauth_input_data * OperateHiAuth(pam_handle_t * pamh)
{
	int retval = 0;
	char * pHiAuthData = NULL;
	struct st_hiauth_input_data *input_data = malloc(sizeof(struct st_hiauth_input_data));

	if (input_data == NULL) {
        	return NULL;
    	}


	for (int i = 0 ; i < HIAUTH_MAX ; i ++ )
	{
		retval = pam_prompt(pamh, PAM_PROMPT_ECHO_ON, &pHiAuthData, nd_hiauth_item[i].item);
		if (retval == PAM_SUCCESS && pHiAuthData)      {
			
			if ( nd_hiauth_item[i].index == HIAUTH_ID)
				snprintf (input_data->sHiAuthId, sizeof (input_data->sHiAuthId), pHiAuthData);
			else if (nd_hiauth_item[i].index == HIAUTH_PW)
				snprintf (input_data->sHiAuthPw, sizeof (input_data->sHiAuthPw), pHiAuthData);
			else	{
			}
			
		}

		free (pHiAuthData);
	}

	return input_data;
}

/*
	//
*/
void  getpamconf(struct st_pam_conf * pam_conf)
{
	
	char * server_pam_mode  = get_value_from_inf(PAM_SETTING_FILE, SECTION_NM_PAM_CONF,    PAM_CONF_KEY_PAM_MODE); 		// PAM_MODE
	char * server_su_mode   = get_value_from_inf(PAM_SETTING_FILE, SECTION_NM_PAM_CONF,    PAM_CONF_KEY_SU_CONTROL);	// PAM_SU_CONTROL
	char * auth_server_ip   = get_value_from_inf(PAM_SETTING_FILE, SECTION_NM_HIAUTH_CONF, PAM_CONF_KEY_SERVERIP);		// SERVER_IP
	char * auth_server_port = get_value_from_inf(PAM_SETTING_FILE, SECTION_NM_HIAUTH_CONF, PAM_CONF_KEY_SERVERPORT);	// SERVER_PORT
	char * auth_server_use  = get_value_from_inf(PAM_SETTING_FILE, SECTION_NM_HIAUTH_CONF, PAM_CONF_KEY_SERVERUSE);		// SERVER_USE

	if (server_pam_mode)	{

		pam_conf->pam_operate_mode = atoi (server_pam_mode);

	}else			{
		pam_conf->pam_operate_mode = OPER_MODE_OFF;
	}

	if (server_su_mode)	{
		pam_conf->su_operate_mode = atoi (server_su_mode);

	}else			{
		pam_conf->su_operate_mode = OPER_MODE_OFF;
	}

	if (auth_server_ip)	{
		strncpy (pam_conf->auth_ip, auth_server_ip, IPV4_BUFFER_SIZE);
		pam_conf->auth_ip[IPV4_BUFFER_SIZE -1] = '\0';
	}else			{
		strncpy (pam_conf->auth_ip, "0.0.0.0", IPV4_BUFFER_SIZE);
	}

	if (auth_server_port)	{
		pam_conf->auth_port = atoi (auth_server_port);
	}else			{
		pam_conf->auth_port = PAM_HIAUTH_DEFAULT_PORT;
	}
}

/*
	// 
*/

int getloginpurpose( pam_handle_t * pamh, const char *tty, const char *service)
{
	if (tty == NULL || service == NULL )
		pam_syslog (pamh, LOG_ERR, "tty or service is null...");
		return -1;
	
	if (strncmp(tty, "/dev/tty", 9) == 0) 		{

        	return AUTH_PURPOS_CONSOLE;  

    	} else if (strncmp(tty, "/dev/pts/", 10) == 0) 	{

        	return AUTH_PURPOS_TERMINAL; 
  	}

	if (strcmp (service, STR_SU) == 0 || strcmp (service, STR_SUL) == 0)	{
		
		return AUTH_PURPOS_SU;
	}

    	return -1;
}

int XXX()
{
	int retval = 0, sock = 0;
	char sSendData[MAX_SEND_DATA] = {0,};
	char sRecvData[MAX_RECV_DATA] = {0,};
	retval = connect_to_server(&sock, "HIAUTH_CONF");

	if (retval != 0 )	{

	}

	else			{
		retval = send_data (sock, sSendData);
		if (retval != 0)	{
			//return FAIL
		}

		retval = receive_data(sock, sRecvData, sizeof (sRecvData));
		if (retval != 0)	{

		}
		
	}
	

	
}

int pam_auth_dummy_func (char * uuid_str,  struct pam_user_info user_info, pam_handle_t * pamh)
{
	int retval = 0, sock = 0;
	char    *hiwareOtp = NULL, *hiwareFido = NULL;
	char    sDataSendBuffer[MAX_SEND_DATA];
        char    sDataRecvBuffer[MAX_RECV_DATA];
	char    sDataEnv_var[MAX_ENV_STR_LEN];

	struct  st_hiauth_input_data    *hiauth_input_data;

	retval = connect_to_server(&sock, "HIAUTH_CONF");
        if (retval != 0 )
        {
                /*
                */
                pam_syslog(pamh, LOG_ERR, "pam_sm_authenticate_ connect server fail.");

                //connect error
                return PAM_AUTH_ERR;
        }

        sprintf (sDataSendBuffer, "USER_CHECK|%s", user_info.username);

        retval = send_data (sock, sDataSendBuffer);
        if (retval != 0 ) // error
        {
                pam_syslog(pamh, LOG_ERR, "pam_sm_authenticate :: fail to send data");
                return PAM_AUTH_ERR;
        }

	retval = receive_data (sock, sDataRecvBuffer, sizeof (sDataRecvBuffer));
        if (retval != 0) // error
        {
                pam_syslog(pamh, LOG_ERR, "pam_sm_authenticate :: fail to recv data");
                return PAM_AUTH_ERR;
        }

	if (strcmp (sDataRecvBuffer, "REQ_HIAUTH") == 0 )
        {
                hiauth_input_data = OperateHiAuth(pamh);
                if (hiauth_input_data == NULL)
                {
                        pam_syslog(pamh, LOG_ERR, "pam_sm_authenticate  fail to OperateHiAuth ...");
                        return PAM_AUTH_ERR;
                }
                else
                {
                        sprintf (sDataSendBuffer, "HIAUTH|%s|%s|%s", hiauth_input_data->sHiAuthId, hiauth_input_data->sHiAuthPw, uuid_str);
                        retval = send_data ( sock, sDataSendBuffer);
                        if (retval != 0 )       // error
                        {
                                pam_syslog(pamh, LOG_ERR, "pam_sm_authenticate :: fail to send data ...");
                                return PAM_AUTH_ERR;
                        }

                        retval = receive_data (sock, sDataRecvBuffer, sizeof (sDataRecvBuffer));
                        if (retval != 0)        // error
                        {
                                pam_syslog(pamh, LOG_ERR, "pam_sm_authenticate :: fail to recv data...");
                                return PAM_AUTH_ERR;
                        }

                        if (strcmp (sDataRecvBuffer, "AUTH_OK") == 0 )
                        {
                                // success
                        }

                        else if (strcmp (sDataRecvBuffer, "AUTH_OTP") == 0  || strcmp (sDataRecvBuffer, "AUTH_FIOD") == 0 )
                        {
                                if (strcmp (sDataRecvBuffer, "AUTH_OTP") == 0 )
                                {
                                        retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF, &hiwareOtp, "otp: ");
                                        if (hiwareOtp != NULL )
                                        {
                                                sprintf (sDataSendBuffer, "AUTH_OTP_REQ|%s", hiwareOtp);
                                        }
                                }

                                else
                                {
                                        retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF, &hiwareFido, "fido: ");
                                        if (hiwareFido != NULL )
                                        {
                                                sprintf (sDataSendBuffer, "AUTH_FIDO_REQ|%s", hiwareFido);
                                        }
                                }

                                if (retval != PAM_SUCCESS )
                                {
                                        if (hiwareOtp)
                                                free (hiwareOtp);
                                        if (hiwareFido)
                                                free (hiwareFido);

                                        return PAM_AUTH_ERR;
                                }


                                retval = send_data (sock, sDataSendBuffer);
                                if (retval != 0 )       // error
                                {
                                        if (hiwareOtp)
                                                free (hiwareOtp);
                                        if (hiwareFido)
                                                free (hiwareFido);

                                        return PAM_AUTH_ERR;
                                }
				
				retval = receive_data (sock, sDataRecvBuffer, sizeof (sDataRecvBuffer));
                                if (retval != 0 ) // error
                                {
                                        if (hiwareOtp)
                                                free (hiwareOtp);
                                        if (hiwareFido)
                                                free (hiwareFido);

                                        return PAM_AUTH_ERR;
                                }

                                if (strcmp (sDataRecvBuffer, "AUTH_OK") != 0 )
                                {
                                        if (hiwareOtp)
                                                free (hiwareOtp);
                                        if (hiwareFido)
                                                free (hiwareFido);

                                        return PAM_AUTH_ERR;
                                }
                        }

                        else
                        {
                                if (hiwareOtp)
                                        free (hiwareOtp);
                                if (hiwareFido)
                                        free (hiwareFido);

                                return PAM_AUTH_ERR;
                        }
		}


		snprintf (sDataEnv_var, sizeof (sDataEnv_var), HIWARE_ACTUAL_NAME_FORMAT, hiauth_input_data->sHiAuthId);
                pam_putenv (pamh, sDataEnv_var);
                memset (sDataEnv_var, 0x00 , sizeof (sDataEnv_var));

                snprintf (sDataEnv_var, sizeof (sDataEnv_var), HIWARE_SESSION_KEY_FORMAT, uuid_str );
                pam_putenv (pamh, sDataEnv_var);
	
	}

	
	return PAM_SUCCESS;
}


PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags,
                                  int argc, const char **argv) {

	int 	retval = 0, sock = 0;
	uuid_t	uuid;
	bool 	bisAlive_server = false;
	struct 	st_pam_conf		pam_conf;
	struct  st_hiauth_input_data	*hiauth_input_data;
	struct 	pam_user_info           user_info;

	char 	*hiwareOtp = NULL, *hiwareFido = NULL;

	char    uuid_str[37] = {0,};
	char 	sDataSendBuffer[MAX_SEND_DATA];
	char    sDataRecvBuffer[MAX_RECV_DATA];
	char 	sDataEnv_var[MAX_ENV_STR_LEN];

	char 	sDataSucceedLog[MAX_LOG_LEN];
	char 	sDataFailedLog[MAX_LOG_LEN];

	/*
		// log item
	*/
	char	sUserAccount[MAX_ACCOUNT_LEN];
	char 	sSwitchAccount[MAX_ACCOUNT_LEN];
	char 	sIpAddress[IPV4_BUFFER_SIZE];
	

	/*
		// creat new uuid
	*/	
	uuid_generate_random(uuid);
        uuid_unparse(uuid, uuid_str);

	/*
		// get pam config
	*/
	getpamconf (&pam_conf);

	
	/*
		// get user session info
	*/
	get_user_info(&user_info, pamh);
	
	/*
		// check api server connect
	*/
	bisAlive_server = check_server_connection(pam_conf.auth_ip, pam_conf.auth_port);
	
	/*
		// get login type (su? terminal, console)
	*/
	retval = getloginpurpose(pamh, user_info.tty, user_info.service);
	switch ( retval )
	{
		case	AUTH_PURPOS_CONSOLE:
		{
			sprintf (sUserAccount, user_info.username);
		}
		break; 
	
		case 	AUTH_PURPOS_TERMINAL:
		{
			sprintf (sUserAccount, user_info.username);
		}
		break;

		case 	AUTH_PURPOS_SU:
		{
			pam_client_info info ;
			info = get_su_master_info(pamh);
			if (info.ip)
				strncpy (sIpAddress, info.ip, sizeof (info.ip));
			else 
				strcpy (sIpAddress, "unknown");
			
			retval = pam_get_item (pamh, PAM_RUSER, (const void**)&sUserAccount);
			if (retval != PAM_SUCCESS || sUserAccount == NULL )
				strcpy (sUserAccount, "unknown");
		}
		break;

		default:
		break;
	}

	retval = pam_auth_dummy_func (uuid_str,  user_info,  pamh);

	if (retval != PAM_SUCCESS )
	{
		return retval;
	}
 
	if (hiwareOtp)
		free (hiwareOtp);
	if (hiwareFido)
		free (hiwareFido);

	return retval;
};


/*
	//Function Definition of Linux PAM Module [pam_sm_authenticate]
*/
PAM_EXTERN int pam_sm_authenticate_(pam_handle_t *pamh, int flags,
                                  int argc, const char **argv) {

	const char 	*input_passwd;
	const char 	*encrypted_passwd;
	const char      *remote_ip;
	const char      *tty;
	const char 	*current_user; 
	const char 	*target_user;

	uuid_t		uuid;

	char 		*hiwareid = NULL, * hiwarepw = NULL, * hiotp = NULL;
	char 		*crypted;
	char 		session_id[SESSION_ID_LENGTH + 1];
	char 		env_var[256];
	char 		sLogData[1024] = {0,};
	char 		sSuLogData[1024] = {0,};
	char 		uuid_str[37] = {0,};
	char 		*pUuid_str = malloc(37 + 1);

	int 		retval, ret = 0;

	uid_t 		uid;
        gid_t 		gid;

	bool 		bRetOtp = false, isConsole = false;
	srand((unsigned)time(NULL));

	struct pam_user_info 		user_info;
	struct pam_rule_info 		rule_info;
	struct pam_log_item		log_item;
	struct st_hiauth_input_data 	*input_data;
	pam_client_info info ;

	pam_config config = {0};

	/*
		// Reading Information from Configuration Files
	*/
	if (read_pam_config(PAM_SETTING_FILE, &config) == 0) 	{
		if (strcmp(config.pam_mode,"ON") != 0 )
			return PAM_SUCCESS;
	}

	memset (&user_info, 0, sizeof (struct pam_user_info));
	memset (&log_item, 0, sizeof (log_item));

	/*
		<get information list>
		- useraccount
		- user input password(real)
		- tty
		- is console
		- encryped password
		- uid
		- gid
		- auth method
		- ip address
		- service (ssh or su or su -l)
		- login time
	*/
	get_user_info(&user_info, pamh);

	
	if (strcmp (user_info.service, STR_SU) == 0 || strcmp (user_info.service, STR_SUL) == 0  )
	{
		const char *current_user; 
    		const char *target_user;

		info = get_su_master_info(pamh);


		retval = pam_get_item(pamh, PAM_AUTHTOK, (const void **)&input_passwd);
                if (retval != PAM_SUCCESS) {
                        nd_log(NDLOG_ERR,"failed to get user password...");
                        return retval;
                }


		if (strlen (input_passwd) <= 0 )
		{

#ifdef _LOGTYPE_V1
			snprintf (sLogData, MAX_LOG_SIZE -1, "su: Authentication failed for %s from %s %s",user_info.username, info.ip,  SERVICE_SSHD_NAME);
                        nd_log (NDLOG_INF, sLogData);
#endif
	
			nd_pam_log_v2("su:auth", "Authentication failed", user_info.username, user_info.ip_address, "00000000-0000-0000-0000-000000000000",
					"Authentication failde for user %s from %s su", user_info.username ,user_info.ip_address);

			return PAM_AUTH_ERR;
		}
		
		encrypted_passwd = get_encrypted_password_from_shadow(user_info.username);
                if (encrypted_passwd == NULL) {
                        nd_log (NDLOG_ERR, "failed to get encrypted passwd from shadow");
                        return PAM_USER_UNKNOWN;

                }

		crypted = crypt(input_passwd, encrypted_passwd);
                if (strcmp(crypted, encrypted_passwd) == 0) {
                        retval = PAM_SUCCESS;
                } else {
#ifdef _LOG_TYPE_V1	
                        snprintf (sLogData, MAX_LOG_SIZE -1, "su: Authentication failed for %s from %s %s",user_info.username, info.ip,  SERVICE_SSHD_NAME);
                        nd_log (NDLOG_INF, sLogData);
#endif

                        nd_pam_log_v2("su:auth", "Authentication failed", user_info.username, user_info.ip_address, "00000000-0000-0000-0000-000000000000",
					"Authentication failde for user %s from %s su", user_info.username ,user_info.ip_address);

                        retval = PAM_AUTH_ERR;
                }

		if (retval != PAM_SUCCESS)
			return retval;

		nd_pam_log_v2("su:auth", "Accepted password",user_info.username,user_info.ip_address,"00000000-0000-0000-0000-000000000000",
				"Accepted password for user %s from %s sshd", user_info.username ,user_info.ip_address);

		
	
    		retval = pam_get_item(pamh, PAM_RUSER, (const void **)&current_user);
    		if (retval != PAM_SUCCESS || current_user == NULL) {
       			 current_user = "unknown"; 
    		}


    		retval = pam_get_user(pamh, &target_user, NULL);
    		if (retval != PAM_SUCCESS || target_user == NULL) {
        		pam_syslog(pamh, LOG_ERR, "Failed to retrieve target user.");
       	 		return PAM_AUTH_ERR;
    		}
#ifdef _LOG_TEPE_V1
		 snprintf (sLogData, MAX_LOG_SIZE -1, "Account %s attempts switch to %s using 'su' [su: %s -> %s, original tty: %s, original IP: %s]",current_user, target_user,current_user, target_user, current_user, info.ip);
		
		nd_log (NDLOG_INF, sLogData);
#endif
		if (strcmp (config.pam_su_control , "ON") != 0)
		{
			return PAM_SUCCESS;
		}

#ifdef _LOG_TYPE_V2
		snprintf (sSuLogData, MAX_LOG_SIZE -1, ND_SULOG_FORMAT, current_user,target_user,user_info.service,info.tty, current_user,info.ip/*, info.port*/);
                nd_sulog (NDLOG_INF, sSuLogData);
#endif 
		nd_pam_sulog_v2 ((char*)current_user,(char*)target_user,user_info.service, info.ip);

		/*
			//create uuid
		*/
		uuid_generate_random(uuid);
		uuid_unparse(uuid, uuid_str);

		input_data = OperateHiAuth(pamh);
		if (input_data == NULL)         {
			return PAM_SYSTEM_ERR;
		}

		int sock;
		char server_ip[16];
		int server_port;

		/*
			// Read server settings
		*/
		if (read_server_config("HIAUTH_CONF", server_ip, sizeof(server_ip), &server_port) != 0) {
			return -1;
		}


		pam_syslog (pamh, LOG_ERR, "auth server ip : %s, port : %d", server_ip, server_port);

		retval = connect_to_server(&sock, "HIAUTH_CONF");
		if (retval != 0 )       {
			pam_syslog (pamh, LOG_ERR, "fail to connect server [%s/%d] (%d)", server_ip, server_port, retval );
		}
		else            {
			pam_syslog (pamh, LOG_ERR, "success connect server!! [%s/%d]", server_ip, server_port );
			char szSendData[1024] = {0,};

			//sprintf (szSendData, "HIAUTH|%s|%s",input_data->sHiAuthId, input_data->sHiAuthPw);
			sprintf (szSendData, "HIAUTH|%s|%s|%s",input_data->sHiAuthId, input_data->sHiAuthPw,uuid_str );
			send_data (sock, szSendData);

			char recv[1024] = {0,};
			receive_data (sock, recv, sizeof (recv));

			pam_syslog (pamh, LOG_ERR, "recv return (%s)", recv);

			if (strcmp (recv, "AUTH_FAIL") == 0 )
			{
				return PAM_AUTH_ERR;
			}
			else if (strcmp (recv, "AUTH_OK") == 0 )
			{
				/*
				sprintf (szSendData, "HISESSIONKEY|%s",uuid_str);
				send_data (sock, szSendData);

				receive_data (sock, recv, sizeof (recv));
				if (strcmp (recv, "AUTH_FIN") == 0 )
				{

				}
				*/

			}
			else if (strcmp (recv, "AUTH_OTP") == 0 )
			{

				retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &hiotp, "OTP: ");
				if (retval != PAM_SUCCESS)      {
					// ERROR
				}

				memset (szSendData, 0x00 , sizeof (szSendData));

				sprintf (szSendData, "AUTH_OTP_REQ|%s", hiotp );


				send_data (sock, szSendData);

				receive_data (sock, recv, sizeof (recv));
				if (strcmp (recv, "AUTH_FAIL") == 0 )
				{
					return PAM_AUTH_ERR;
				}

				/*
				 sprintf (szSendData, "HISESSIONKEY|%s",uuid_str);
				send_data (sock, szSendData);

				receive_data (sock, recv, sizeof (recv));
				if (strcmp (recv, "AUTH_FIN") == 0 )
				{

				}
				*/

			}
			else if (strcmp (recv, "AUTH_FIDO") == 0 )
			{
				retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &hiotp, "FIDO: ");
				if (retval != PAM_SUCCESS)      {
					// ERROR
				}

				memset (szSendData, 0x00 , sizeof (szSendData));

				sprintf (szSendData, "AUTH_FIDO_REQ|%s", hiotp );


				send_data (sock, szSendData);

				receive_data (sock, recv, sizeof (recv));
				if (strcmp (recv, "AUTH_FAIL") == 0 )
				{
					nd_pam_log_v2("sshd:auth", "Permission denied",user_info.username,user_info.ip_address,"00000000-0000-0000-0000-000000000000", "Permission denied for user %s from %s su", user_info.username ,user_info.ip_address);

					return PAM_AUTH_ERR;
				}

			}


			/*
				// Store the hiware ID information in an environment variable.
			*/
			snprintf(env_var, sizeof(env_var), HIWARE_ACTUAL_NAME_FORMAT, input_data->sHiAuthId);
			pam_putenv(pamh, env_var);

			snprintf (env_var, sizeof (env_var), HIWARE_SESSION_KEY_FORMAT, uuid_str);
                        pam_putenv(pamh, env_var);




		}

		if (find_match_su_rule_for_connnectinfo (current_user, info.ip, target_user) == false)
		{
#ifdef _LOG_TYPE_V1
			nd_log(NDLOG_ERR, "The request from a user without permission to use the su command has been canceled.");
#endif

                        nd_pam_log_v2("sshd:auth", "Permission denied", user_info.username,user_info.ip_address,"00000000-0000-0000-0000-000000000000",
					"Permission denied for user %s from %s su", user_info.username ,user_info.ip_address );

			retval = PAM_PERM_DENIED;
		}
		else
		{
			/*
				//set guid
			*/
			set_pam_data (pamh, ND_SESSION_KEY, uuid_str, cleanup_func);

			snprintf (env_var, sizeof (env_var), ND_SESSION_KEY, uuid_str);
			pam_putenv(pamh, env_var);
			memset (&env_var, 0, sizeof (env_var));
			
			snprintf(env_var, sizeof(env_var), HIWARE_ACTUAL_NAME_FORMAT,hiwareid );
                	pam_putenv(pamh, env_var);
#ifdef _LOG_TEPE_V1
                        nd_log (NDLOG_INF, "Set HIWARE account(%s) information in the environment variables of the authenticated session", target_user);
#endif

			nd_pam_log_v2("su:auth","Accepted Multi-Prompt Verification", user_info.username,user_info.ip_address,uuid_str,
					"Accepted Multi-Prompt Verification for user %s from %s sshd", user_info.username ,user_info.ip_address);
			///

			retval = PAM_SUCCESS;

		}

		free(hiwareid);
                free(hiwarepw);
	}
	else
	{
		strcpy (rule_info.username, 	user_info.username);
		strcpy (rule_info.ipaddr, 	user_info.ip_address);

		/*
                        //create uuid
                */
                uuid_generate(uuid);
                uuid_unparse(uuid, uuid_str);

		sprintf (g_sAccount, 		user_info.username);

		retval = pam_get_item(pamh, PAM_AUTHTOK, (const void **)&input_passwd);
		if (retval != PAM_SUCCESS) {
			nd_log(NDLOG_ERR,"failed to get user password...");
			return PAM_AUTH_ERR;
		}

		encrypted_passwd = get_encrypted_password_from_shadow(user_info.username);
		if (encrypted_passwd == NULL) {
			nd_log (NDLOG_ERR, "failed to get encrypted passwd from shadow");
			return PAM_USER_UNKNOWN;
		
		}

		crypted = crypt(input_passwd, encrypted_passwd);
		if (strcmp(crypted, encrypted_passwd) == 0) {
			retval = PAM_SUCCESS;
			reset_fail_count(user_info.username);
		} else {
			const char *msg = "Permission denied, please try again.";
			pam_error(pamh, msg);

			increment_fail_count(user_info.username);		
#ifdef _LOG_TYPE_V1
			snprintf (sLogData, MAX_LOG_SIZE -1, "Authentication failed for %s from %s %s",user_info.username, user_info.ip_address,  SERVICE_SSHD_NAME);
			nd_log (NDLOG_INF, sLogData);
#endif 

                        nd_pam_log_v2("sshd:auth", "Permission denied",user_info.username,user_info.ip_address,"00000000-0000-0000-0000-000000000000",
					"Permission denied for user %s from %s su", user_info.username ,user_info.ip_address);


			int fail_count = read_fail_count(user_info.username);
			if (fail_count >= MAX_FAILED_ATTEMPTS) {
				return PAM_MAXTRIES;
			}

			return PAM_AUTH_ERR;
		}

		if (retval == PAM_SUCCESS)
		{
			/*
			//save login log
			*/
#ifdef _LOG_TEPE_V1
			snprintf (sLogData, MAX_LOG_SIZE -1, "Accepted password for %s from %s %s",user_info.username, user_info.ip_address,  SERVICE_SSHD_NAME);
			nd_log (NDLOG_INF, sLogData);
#endif
			nd_pam_log_v2("sshd:auth","Accepted password",user_info.username,user_info.ip_address,"00000000-0000-0000-0000-000000000000",
					"Accepted password for user %s from %s sshd", user_info.username ,user_info.ip_address);

			bool bIsMfa = false;
			if (find_match_rule_for_connnectinfo (user_info.username, user_info.ip_address/*, &bIsMfa*/) )
			{

				/*
					//After performing communication tasks with the API server, 
					//if it is received that Hiware authentication is required, the Hiware authentication message will be displayed.
				*/
				bIsMfa = true;
					
				if (bIsMfa == true)
				{
					input_data = OperateHiAuth(pamh);
    					if (input_data == NULL) 	{
        					return PAM_SYSTEM_ERR;
    					}

					int sock;
					char server_ip[16];
					int server_port;

					/*
						// Read server settings
					*/
					if (read_server_config("HIAUTH_CONF", server_ip, sizeof(server_ip), &server_port) != 0) {
						return -1;
					}


					pam_syslog (pamh, LOG_ERR, "auth server ip : %s, port : %d", server_ip, server_port);
				
					retval = connect_to_server(&sock, "HIAUTH_CONF");
					if (retval != 0 )	{
						pam_syslog (pamh, LOG_ERR, "fail to connect server [%s/%d] (%d)", server_ip, server_port, retval );
					}
					else		{
						pam_syslog (pamh, LOG_ERR, "success connect server!! [%s/%d]", server_ip, server_port );
						char szSendData[1024] = {0,};

						sprintf (szSendData, "HIAUTH|%s|%s|%s",input_data->sHiAuthId, input_data->sHiAuthPw,uuid_str );
						send_data (sock, szSendData);

						char recv[1024] = {0,};
						receive_data (sock, recv, sizeof (recv));

						pam_syslog (pamh, LOG_ERR, "recv return (%s)", recv);

						if (strcmp (recv, "AUTH_FAIL") == 0 )
						{
							return PAM_AUTH_ERR;
						}
						else if (strcmp (recv, "AUTH_OK") == 0 )
						{
							/*
							sprintf (szSendData, "HISESSIONKEY|%s",uuid_str);
							send_data (sock, szSendData);

							receive_data (sock, recv, sizeof (recv));
							if (strcmp (recv, "AUTH_FIN") == 0 )
							{

							}
							*/

						}
						else if (strcmp (recv, "AUTH_OTP") == 0 )
						{

							retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &hiotp, "OTP: ");
                                        		if (retval != PAM_SUCCESS)      {
								// ERROR
                                        		}

							memset (szSendData, 0x00 , sizeof (szSendData));

							sprintf (szSendData, "AUTH_OTP_REQ|%s", hiotp );


							send_data (sock, szSendData);

							receive_data (sock, recv, sizeof (recv));
							if (strcmp (recv, "AUTH_FAIL") == 0 )
							{
								nd_pam_log_v2("sshd:auth", "Permission denied",user_info.username,user_info.ip_address,"00000000-0000-0000-0000-000000000000", "Permission denied for user %s from %s su", user_info.username ,user_info.ip_address);

								return PAM_AUTH_ERR;
							}
							/*
							 sprintf (szSendData, "HISESSIONKEY|%s",uuid_str);
                                                        send_data (sock, szSendData);

                                                        receive_data (sock, recv, sizeof (recv));
                                                        if (strcmp (recv, "AUTH_FIN") == 0 )
                                                        {

                                                        }
							*/

						}
						else if (strcmp (recv, "AUTH_FIDO") == 0 )
						{
							retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &hiotp, "FIDO: ");
                                                        if (retval != PAM_SUCCESS)      {
                                                                // ERROR
                                                        }

                                                        memset (szSendData, 0x00 , sizeof (szSendData));

                                                        sprintf (szSendData, "AUTH_FIDO_REQ|%s", hiotp );


                                                        send_data (sock, szSendData);

                                                        receive_data (sock, recv, sizeof (recv));
                                                        if (strcmp (recv, "AUTH_FAIL") == 0 )
                                                        {
                                                                nd_pam_log_v2("sshd:auth", "Permission denied",user_info.username,user_info.ip_address,"00000000-0000-0000-0000-000000000000", "Permission denied for user %s from %s su", user_info.username ,user_info.ip_address);

                                                                return PAM_AUTH_ERR;
                                                        }

						}
						
					}
					
					

					/*
						// Store the hiware ID information in an environment variable.
					*/
					snprintf(env_var, sizeof(env_var), HIWARE_ACTUAL_NAME_FORMAT, input_data->sHiAuthId);
                                        pam_putenv(pamh, env_var);
		
					
					snprintf (env_var, sizeof (env_var), HIWARE_SESSION_KEY_FORMAT, uuid_str);
					pam_putenv(pamh, env_var);


					nd_pam_log_v2("sshd:auth","Accepted Multi-Prompt Verification",user_info.username,user_info.ip_address,
						(char*)uuid_str,
						"Accepted Multi-Prompt Verification for user %s from %s sshd", user_info.username ,user_info.ip_address);

#ifdef _LOG_TEPE_V1
					snprintf (sLogData, MAX_LOG_SIZE -1, ND_LOGIN_MFA_ACCEPTED_MSG_FORMAT, user_info.username, user_info.ip_address,  SERVICE_SSHD_NAME);
					nd_log (NDLOG_INF, sLogData);
#endif
					free (input_data);
				}

				g_isLogin = true;
			}
			else //Excluded by policy
			{
				snprintf (sLogData, MAX_LOG_SIZE -1, ND_LOGIN_MFA_EXCLUDED_MSG_FORMAT, user_info.username, user_info.ip_address,  SERVICE_SSHD_NAME);
				nd_log (NDLOG_INF, sLogData);
			}
		}
		else
		{
			//nd_log (NDLOG_ERR, "User %s login operation failed - Primary authentication failed\n", user);
			return PAM_AUTH_ERR;
		}

		free(hiwareid);
		free(hiwarepw);
	}
Exit:
	return retval;
}

/*
        //Function Definition of Linux PAM Module [pam_sm_setcred]
*/
PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags,
                             int argc, const char **argv) {
	return PAM_SUCCESS;
}

/*
        //Function Definition of Linux PAM Module [pam_sm_acct_mgmt]
*/
/*
PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags,
                               int argc, const char **argv) {

	return PAM_SUCCESS;
}
*/
/*
        //Function Definition of Linux PAM Module [pam_sm_open_session]
*/
PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags,
                                  int argc, const char **argv) {
	system("clear");
	
	uid_t uid;
	gid_t gid;
	const char *service;
	const char *remote_ip;
	bool isConsole = 0;
	//char *ip_address;
	char ip_address[INET_ADDRSTRLEN];
	const char *tty;
	const char *username;
	char *session_id = malloc(SESSION_ID_LENGTH + 1); 
	char line[256];
	char env_var[256];
    	int found = 0;
	int retval;
	bool isSuSession = false;
	int nSuType = 0;
	char sSuType[128] = {0,};

	pam_config config = {0};

	char action_type[128];
	char message[1280];
	char szSessionKey[37];

	pam_client_info info ;
	struct pam_log_item log_item;

        if (read_pam_config(PAM_SETTING_FILE, &config) != 0)    {
/*                if (strcmp(config.pam_mode,"ON") != 0 )
                        return PAM_SUCCESS;
*/		
		return PAM_SUCCESS;
        }


	if (strcmp(config.pam_mode,"ON") == 0 )
	{
		/*
			//
		*/
		print_nd_banner ();

		print_nd_warnning_msg ();
	}
	/*
                //
        */

	if (session_id == NULL) {
        	return PAM_BUF_ERR; // 메모리 할당 실패
    	}

	retval = pam_get_item(pamh, PAM_SERVICE, (const void **)&service);
    	if (retval != PAM_SUCCESS) {
        	return retval;
    	}

	if (service != NULL)
	{
		if (strcmp (service, STR_SU) == 0 || strcmp (service, STR_SUL) == 0)
		{
			snprintf (sSuType,sizeof (sSuType), service);
			isSuSession = true;
		}
	}

	if (pam_get_user(pamh, &username, NULL) != PAM_SUCCESS) {
        	return PAM_SYSTEM_ERR;
    	}

	memset (session_id, 0x00, SESSION_ID_LENGTH);
	generate_session_id(session_id, SESSION_ID_LENGTH);

	struct passwd *pw = getpwnam(username);
        if (pw != NULL) {
                uid = pw->pw_uid;
                gid = pw->pw_gid;
        }

	pam_get_item(pamh, PAM_TTY, (const void **)&tty);
        if (tty)        {

                if (strncmp(tty, "tty", 3) == 0 )       {
                        isConsole = true;
                }
        }

	retval = pam_get_item(pamh, PAM_SERVICE, (const void **)&service);
        if (retval != PAM_SUCCESS) {
                return retval;
        }

	if (service != NULL)
        {
                if (strcmp (service, STR_SU) == 0 || strcmp (service, STR_SUL) == 0)    {


                        snprintf (sSuType,sizeof (sSuType), service);
                        isSuSession = true;


                        const char *value;
                        value = pam_getenv(pamh, ND_HIWARE_ACTUALNM_KEY);
                        const char *previous_user;
                        const char *target_user;
                        const char *command;


                        const char *ssh_connection = getenv("SSH_CONNECTION");
                        char ip_address[INET_ADDRSTRLEN];

                        if (ssh_connection)
                        {
                                char *token = strtok((char *)ssh_connection, " ");
                                if (token != NULL) {
                                        strncpy(ip_address, token, sizeof(ip_address));
                                        ip_address[sizeof(ip_address) - 1] = '\0';
                                        strncpy(info.ip, token, INET_ADDRSTRLEN);
                                        info.ip[INET_ADDRSTRLEN - 1] = '\0';
                                        token = strtok(NULL, " ");
                                        if (token != NULL) {
                                                strncpy(info.port, token, sizeof(info.port));
                                                info.port[sizeof(info.port) - 1] = '\0';
                                        }
                                }
                                else
                                {
                                        strcpy(ip_address, "NONE");
                                }
                        }
			else
                        {

                                info = get_su_master_info(pamh);
                                if (info.ip)
                                {
                                        strncpy(ip_address, info.ip, sizeof(ip_address));
                                }
                                else
                                {
                                        strcpy(ip_address, "NONE");
                                }

                        }
		}
/*
		else
		{
			pam_syslog(pamh, LOG_ERR, "open session test - 005~");
			if (isConsole == false )        {

				pam_syslog(pamh, LOG_ERR, "open session test - 005-1");
				int retval = pam_get_item(pamh, PAM_RHOST, (const void **)&ip_address);
				if (retval == PAM_SUCCESS && ip_address) {
				} else {
				       // nd_log(NDLOG_ERR,"fail to get remote ip address");
				}

			}else
			{
				pam_syslog(pamh, LOG_ERR, "open session test - 005-2");
				//ip_address = PAM_LOOPIPADDR;
			}


		}
*/

	}


	if (isConsole == false )        {
                retval = pam_get_item(pamh, PAM_RHOST, (const void **)&remote_ip);
                if (retval == PAM_SUCCESS && remote_ip) {

                        snprintf (ip_address, sizeof (ip_address), remote_ip);
                } else
                {
                        const char *ssh_connection = getenv("SSH_CONNECTION");
                        if (ssh_connection)
                        {
                                char *token = strtok((char *)ssh_connection, " ");
                                if (token != NULL) {

                                        strncpy(ip_address, token, sizeof(ip_address));
                                        ip_address[sizeof(ip_address) - 1] = '\0';
                                }
                                else
                                {
                                        strcpy(ip_address, "NONE");
                                }
                        }
                        else
                        {
                                info = get_su_master_info(pamh);
                                if (info.ip)
                                {
                                        strncpy(ip_address, info.ip, sizeof(ip_address));
                                }
                                else
                                {
                                        strcpy(ip_address, "NONE");
                                }

                        }
                }
        }
        else
        {
                remote_ip = PAM_LOOPIPADDR;
                snprintf (ip_address, sizeof (ip_address), remote_ip);
        }


	const char * previous_user;
	retval = pam_get_item(pamh, PAM_RUSER, (const void **)&previous_user);
        if (retval != PAM_SUCCESS || previous_user == NULL) {
        	previous_user = "unknown";
        }

#ifdef _LOG_TYPE_V1
	char szSessionLog[1024] = {0,};
	sprintf (szSessionLog, "%s|%s|%d|%d|%d|%s|%ld",session_id, username, uid, gid, isConsole, isSuSession? sSuType:ip_address, (long)time(NULL));
	nd_pam_session_log(NDSLOG_LOGIN, szSessionLog);
#endif
	nd_pam_session_log_v2 (ND_PREFIX_LOGIN, session_id, (char*)username, uid, gid, isConsole, ip_address, (long)time(NULL)); 

	const char *sessionkey = pam_getenv(pamh, "HIWARE_SESSION_KEY");
	
	if (isSuSession == true)
                sprintf (action_type, "su:session");
        else
                sprintf (action_type, "sshd:session");

	if (isSuSession == true)
		sprintf (message, "session opened for user %s by %s(uid=%d)", username, previous_user, uid);
	else 
		sprintf (message, "session opened for user %s", username);

	pam_syslog(pamh, LOG_ERR, "open session test - 009");
	char * cUsername = (char *)username;

	nd_pam_log_v2(action_type, "session_open",cUsername, ip_address, (char*)sessionkey, message);

	
	if (set_pam_data (pamh, PAM_DATA_SESSIONID, session_id, cleanup_func) != PAM_SUCCESS)
	{
		free(session_id); 
		nd_log (NDLOG_ERR, "Failed to add session ID to PAM information.");
		return PAM_SYSTEM_ERR;
	}
	
	free(session_id);
	return PAM_SUCCESS;
}

/*
        //Function Definition of Linux PAM Module [pam_sm_close_session]
*/
PAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags,
                                   int argc, const char **argv) {

	const char *user;
        const char *input_passwd;
        const char *encrypted_passwd;
        char *crypted;
        const char *remote_ip;
        char hostname[256];
        int retval, ret = 0;
        const char *tty;
        char szTty[128] = {0,};
	bool isConsole = false;
	char szMsg[1024] = {0,};
	uid_t uid;
        gid_t gid;
	const char *username;
        const char *session_id;
	const char *session_key;
	const char *service;
        bool isSuSession = false;
	char sSuType[128] = {0,};

	const char * szClientPort;
	char ip_address[INET_ADDRSTRLEN];

    	char timestamp[26];
	char            sLogData[1024] = {0,};
        char            sSuLogData[1024] = {0,};
	char 		action_type[128] = {0,};

	const void *retrieved_data;

	const char *previous_user;  // 바로 이전 사용자
        const char *target_user;

	pam_client_info info ;
	struct pam_log_item log_item;


	if (pam_get_user(pamh, &username, NULL) != PAM_SUCCESS) {
                return PAM_SYSTEM_ERR;
        }

	struct passwd *pw = getpwnam(username);
        if (pw != NULL) {
                uid = pw->pw_uid;
                gid = pw->pw_gid;
        }

	retval = pam_get_item(pamh, PAM_SERVICE, (const void **)&service);
        if (retval != PAM_SUCCESS) {
                return retval;
        }

	if (service != NULL)
	{
		if (strcmp (service, STR_SU) == 0 || strcmp (service, STR_SUL) == 0)	{

			
			snprintf (sSuType,sizeof (sSuType), service);
			isSuSession = true;
			

			const char *value;
			value = pam_getenv(pamh, ND_HIWARE_ACTUALNM_KEY);
			const char *previous_user;
			const char *target_user;
			const char *command;


			const char *ssh_connection = getenv("SSH_CONNECTION");
			char ip_address[INET_ADDRSTRLEN];

			if (ssh_connection)
			{
				char *token = strtok((char *)ssh_connection, " ");
				if (token != NULL) {

					strncpy(ip_address, token, sizeof(ip_address));
					ip_address[sizeof(ip_address) - 1] = '\0';
					strncpy(info.ip, token, INET_ADDRSTRLEN);
					info.ip[INET_ADDRSTRLEN - 1] = '\0';
					token = strtok(NULL, " ");
					if (token != NULL) {
						strncpy(info.port, token, sizeof(info.port));
						info.port[sizeof(info.port) - 1] = '\0';
					}
				}
				else
				{
					strcpy(ip_address, "NONE");
				}
			}
			else
			{

				info = get_su_master_info(pamh);
				if (info.ip)
				{
					strncpy(ip_address, info.ip, sizeof(ip_address));
				}
				else
				{
					strcpy(ip_address, "NONE");
				}

			}

			retval = pam_get_item(pamh, PAM_RUSER, (const void **)&previous_user);
			if (retval != PAM_SUCCESS || previous_user == NULL) {
				 previous_user = "unknown";
			}


			retval = pam_get_user(pamh, &target_user, NULL);
			if (retval != PAM_SUCCESS || target_user == NULL) {
				pam_syslog(pamh, LOG_ERR, "Failed to retrieve target user.");
				return PAM_AUTH_ERR;
			}
#ifdef _LOG_TYPE_V2
			snprintf (sLogData, MAX_LOG_SIZE -1, "Account %s attempts switch to %s using 'su' [su: %s -> %s, original tty: %s, original IP: %s]", previous_user, target_user,previous_user, target_user, previous_user, ip_address);

			nd_log (NDLOG_INF, sLogData);
#endif 
			char * cUsername = (char *)username;
			nd_pam_log_v2("su:session", "attempts switch",cUsername,ip_address,"18029542-addf-fc3a-0900-08002708b016",
					"Account %s attempts switch to %s using \'su\'", previous_user);


               	 	retval = get_pam_data (pamh, "ND_CLIENT_PORT", (const void **)&szClientPort);

			if (strlen (info.port) <= 0 )
				sprintf (info.port, szClientPort);

//			snprintf (sSuLogData, MAX_LOG_SIZE -1, ND_SULOG_FORMAT,target_user,previous_user,service,info.tty, previous_user,info.ip/*, szClientPort? szClientPort:info.port*/);
//			
#ifdef _LOG_TYPE_V2
			nd_sulog (NDLOG_INF, sSuLogData);
#endif
			char  * orgsccount = ( char *) target_user;
                	char  * switchAccount = ( char *) previous_user;
			char  * service_name = ( char *) service;
			nd_pam_sulog_v2 (orgsccount,switchAccount,service_name, info.ip);
		}
	}

	if (gethostname(hostname, sizeof(hostname)) == 0) {
	} else {
		nd_log (NDLOG_ERR, "Failed to obtain the hostname.");
	}

	pam_get_item(pamh, PAM_TTY, (const void **)&tty);
	if (tty)        {

		if (strncmp(tty, "tty", 3) == 0 )       {
			isConsole = true;
		}
	}


	if (isConsole == false )        {
		retval = pam_get_item(pamh, PAM_RHOST, (const void **)&remote_ip);
		if (retval == PAM_SUCCESS && remote_ip) {
			
			snprintf (ip_address, sizeof (ip_address), remote_ip);
		} else 
		{
			const char *ssh_connection = getenv("SSH_CONNECTION");
			if (ssh_connection)
			{
				char *token = strtok((char *)ssh_connection, " ");
				if (token != NULL) {

					strncpy(ip_address, token, sizeof(ip_address));
					ip_address[sizeof(ip_address) - 1] = '\0';
				}
				else
				{
					strcpy(ip_address, "NONE");
				}
			}
			else
			{
				info = get_su_master_info(pamh);
				if (info.ip)
				{
					strncpy(ip_address, info.ip, sizeof(ip_address));
				}
				else
				{
					strcpy(ip_address, "NONE");
				}

			}
		}
	}
	else
	{	
		remote_ip = PAM_LOOPIPADDR;
		snprintf (ip_address, sizeof (ip_address), remote_ip);
	}

	retval = pam_get_item(pamh, PAM_RUSER, (const void **)&previous_user);
	if (retval != PAM_SUCCESS || previous_user == NULL) {
		 previous_user = "unknown";
	}
	
	retval = pam_get_user(pamh, &target_user, NULL);
	if (retval != PAM_SUCCESS || target_user == NULL) {
		pam_syslog(pamh, LOG_ERR, "Failed to retrieve target user.");
		return PAM_AUTH_ERR;
	}
#ifdef _LOG_TEPE_V1
	if (isSuSession)
	{
		nd_log (NDLOG_INF,"Account %s attempts switch to %s using 'su' [su: %s -> %s, original tty: %s, original IP: %s]",username,previous_user,username,previous_user,previous_user,ip_address);
		const char * szClientPort;
		retval = get_pam_data (pamh, "ND_CLIENT_PORT", (const void **)&szClientPort);
		snprintf (sSuLogData,sizeof (sSuLogData) ,ND_SULOG_FORMAT,username, previous_user,service,info.tty, previous_user,info.ip/*, szClientPort? szClientPort:info.port*/);
                nd_sulog (NDLOG_INF, sSuLogData);

	}
	else
	{
		nd_log (NDLOG_INF, "Disconnected from user %s %s",username, remote_ip);
	}

#endif


	if (isSuSession == true)
                sprintf (action_type, "su:session");
        else
                sprintf (action_type, "sshd:session");

	char szSessionKey[37];
	get_pam_data(pamh, ND_SESSION_KEY, (const void **)&session_key);

	char * cUsername = (char *)username;
        nd_pam_log_v2(action_type, "session closed", cUsername, ip_address,(char*)session_key,"session closed for user %s", target_user);
	
	retval = get_pam_data (pamh, PAM_DATA_SESSIONID, (const void **)&session_id);
	if (retval == PAM_SUCCESS && session_id != NULL)	{

#ifdef _LOG_TYPE_V1
		char szSessionLog[1024] = {0,};
		sprintf (szSessionLog, "%s|%s|%d|%d|%d|%s|%ld",session_id, username, uid, gid, isConsole, isSuSession? info.ip:remote_ip, (long)time(NULL));
		nd_pam_session_log(NDSLOG_LOGOFF, szSessionLog);
#endif 
		nd_pam_session_log_v2 (ND_PREFIX_LOGOUT, (char*)session_id, (char *) username , uid, gid, isConsole, (char*)ip_address, (long)time(NULL));

	}
	else
	{
		nd_log (NDLOG_ERR, "Unable to retrieve the information for the registered session ID during login.");
	}

	return PAM_SUCCESS;
}

/*
        //Function Definition of Linux PAM Module [pam_sm_chauthtok]
*/
PAM_EXTERN int pam_sm_chauthtok(pam_handle_t *pamh, int flags,
                               int argc, const char **argv) {

	return PAM_SUCCESS;
}

__attribute__((constructor)) void init() {

	struct timeval tv;
	gettimeofday(&tv, NULL);
	srand(tv.tv_usec);
	pthread_mutex_init(&session_id_mutex, NULL); // 뮤텍스 초기화
}

__attribute__((destructor)) void cleanup() {
	pthread_mutex_destroy(&session_id_mutex); // 뮤텍스 정리
}
